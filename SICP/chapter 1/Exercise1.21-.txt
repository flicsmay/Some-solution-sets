/***********************************************
		Exercise 1.21
***********************************************/


 /****************** 1.21 **********************/
 
 199: 199
 1999: 1999
 19999: 7
 
 
 /****************** 1.22 **********************/
 
 #lang planet neil/sicp

(define (smallest-divisor n)
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))
  (define (square n) (* n n))
  (define (divides? a b)
    (= (remainder b a) 0))
  
  (find-divisor n 2))

(define (prime? n)
  (= n (smallest-divisor n)))


(define (find-continue-primes n count)
  (cond ((= count 0) (display "are primes.\n"))
        ((prime? n) (display n)
                    (newline)
                    (find-continue-primes (+ n 1) (- count 1)))
        (else (find-continue-primes (+ n 1) count))))

(define (counting-run-time n count)
  (let ((start-time (runtime)))
    (find-continue-primes n count)
    (newline)
    (display (- (runtime) start-time))))
	
	
	
 my test:
 > (counting-run-time 1000 3)
1009
1013
1019
are primes.

73000
> (counting-run-time 10000 3)
10007
10009
10037
are primes.

70000
> (counting-run-time 100000 3)
100003
100019
100043
are primes.

81000
> (counting-run-time 1000000 3)
1000003
1000033
1000037
are primes.

83000
> (counting-run-time 10000000 3)
10000019
10000079
10000103
are primes.

83000
//there are no much of difference.

 /****************** 1.23 **********************/
 
 (define (smallest-divisor n)
  (define (next-odd n)
  (if (= n 2)
      3
      (+ n 2)))
  
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (next-odd test-divisor)))))
  (define (square n) (* n n))
  (define (divides? a b)
    (= (remainder b a) 0))
 
 
 
 /****************** 1.24 **********************/
 
 (define (expmod base exp m)
  (define (square x) (* x x))
  
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

(define (counting-time-fast n times)
  (let ((start-time (runtime)))
    (display (fast-prime? n times))
    (newline)
    (display (- (runtime) start-time))))
 
> (counting-time-fast 1009 10)
#t
17000
> (counting-time-fast 1013 10)
#t
12000
> (counting-time-fast 1019 10)
#t
23000
> (counting-time-fast 10007 10)
#t
11000
> (counting-time-fast 10009 10)
#t
11000
> (counting-time-fast 10037 10)
#t
12000
> (counting-time-fast 100003 10)
#t
15000
> (counting-time-fast 100019 10)
#t
27000
> (counting-time-fast 100043 10)
#t
17000
 
 
 /****************** 1.25 **********************/
 
 It works, but not as good as the former one when there
 are two input numbers which both are very large.
 
 
 /****************** 1.26 **********************/
 
 it compute twice '(expmod base (/ exp 2) m)' when exp are even.
 
 
 /****************** 1.27 **********************/
 
 
 
 
 
 
 
 
 
 